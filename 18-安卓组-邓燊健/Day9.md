## Day9
### 一、接口和抽象类的区别
* a、相同点：
>①：都位于继承的顶端，用于被其他实现或继承  
②：都不能实例化  
③：都包含抽象方法
* b、不同点：
> ①：接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中定义的方法，而抽象类的方法可以在抽象类中被实现  
②：接口需要用implements实现，抽象类只能被继承（extends)  
③：接口中定义的成员变量默认修饰符为public static final（不能被修改），抽象类可以有自己的数据成员变量，也可以有非抽象的成员变量，而且抽象类中的成员变量默认为default；抽象类中的方法前面有abstract修饰
* a、两者的使用情况：
> 1、优先选用接口，尽量少用抽象类  
2、需要定义子类的行为，又要为子类提供共性功能时才选用抽象类


### 二、多态
* a、定义：某一类事物的多种存在形态
1、例：动物中的猫、狗
> ①：猫这个对象对应的类型是猫类型  猫 X=new 猫();  
②：同时猫也是动物中的一种，也可以把猫称为动物  动物 Y=new 猫();  
③：动物是猫和狗具体事物中抽取出来的父类型  
④：父类型引用子类对象
### 三、匿名内部类
* a、定义：适合只使用一次的类
* b、解析：不是抽象类，因为系统在创建匿名内部类的时候，会立即创建匿名内部类的对象
* c、匿名内部类的使用方法：匿名内部类不能定义构造器，因为匿名内部类没有类名
* d、格式：
```
new 父类构造器([实参列表])或接口()
{
//匿名内部类的类体部分
}
```
### 四、枚举类
* a、定义：使用enum声明，默认直接继承java.lang.Enum类，而不是Object类
* b、枚举类的对象是固定的，实例个数有限，不可以再new()，枚举对象后可跟()
* c、枚举元素必须位于枚举类体中最开始部分，枚举元素后要有分号与其他成员分隔
* d、枚举类的构造方法的权限修饰符默认是private
* e、一旦枚举对象后面加上{}，那么该对象实际是枚举匿名内部类对象
* f、所有枚举类都提供一个静态的values()方法（返回该枚举类所有对象组成的数组），便于遍历所有枚举对象
* h、所有枚举类都提供一个静态的valuesOf（String name）方法，返回枚举类中对象名等于name的对象
* j、枚举覆写接口抽象方法的两种方式:
> ①：在枚举中实现接口的抽象方法  
②：在枚举匿名内部类中实现接口的抽象方法
### 五、异常处理和常用类
* a、异常的定义：
就是不正常，是指程序在运行时出现的不正常情况，其实就是程序中出现的问题。
* b、常见异常现象：角标越界、空指针等
* c、异常的体系 Throwable
> ①：Error 通常指JVM出现重大的问题如：运行的类不存在或者内存溢出；不需要编写针对代码对其处理，该程序无法处理  
②：Exception 在运行时运行出现的情况，可以通过try、catch、finally处理
* d、异常处理两种方式：
> ①：捕获异常：try catch直接处理可能出现的异常  
②：声明异常：throws声明告诉调用者可能的异常，暴露问题，调用者自己处理
* e、Exception和Error的相同点  
①：Exception和Error的子类名大都是以父类名作为后缀
* f、异常处理的5个关键字：  
try、catch、finally、throw、throws
* g、捕获异常的顺序：先捕获小异常再捕获大异常
* h、异常处理格式:
```
try
{
	//可能出异常的代码
}
catch(异常类 对象)
{
	//处理异常类型的语句
}
[finally]
{
	//一定会执行的代码
	//catch块使用System.exit(1);除外
}
//注意：当try语句块出现异常，程序会自动跳到catch语句块去找匹配的异常类型，并执行异常处理语句，finally语句块是异常的统一出口	
```
***